<div id="root"></div>
<script type="text/babel">
    // START OF CORRECTED CODE
    // Fix: Replaced ES Module imports with global variable access for UMD/script-tag environment
    const { useState, useEffect, useRef } = React; 
    
    // NOTE: The name of the global variable for 'lucide-react' may vary (e.g., lucide, lucide_react, LucideReact).
    // We will use a fallback approach or assume 'LucideReact' for the components.
    // If LucideReact is not defined, this component will fail.
    const Mountain = window.LucideReact ? window.LucideReact.Mountain : () => <svg />;
    const Circle = window.LucideReact ? window.LucideReact.Circle : () => <svg />;
    const Square = window.LucideReact ? window.LucideReact.Square : () => <svg />;
    const Diamond = window.LucideReact ? window.LucideReact.Diamond : () => <svg />;
    
    // Fallback if the UMD bundle exposes them globally by name (less common but possible):
    // const Mountain = window.Mountain; 
    
    const MountainBikeGame = () => {
        const [screen, setScreen] = useState('menu');
        const [selectedBike, setSelectedBike] = useState(null);
        const [selectedMap, setSelectedMap] = useState(null);
        const [selectedTrail, setSelectedTrail] = useState(null);
        const canvasRef = useRef(null);
        const animationRef = useRef(null);
        const keysRef = useRef({});

        const bikes = [
            { id: 1, name: 'Cross Country', speed: 1.3, handling: 1.0, jump: 1.0, color: '#FF6B6B' },
            { id: 2, name: 'Trail Bike', speed: 1.1, handling: 1.2, jump: 1.2, color: '#4ECDC4' },
            { id: 3, name: 'Enduro', speed: 1.0, handling: 1.4, jump: 1.4, color: '#45B7D1' },
            { id: 4, name: 'Downhill', speed: 0.9, handling: 1.6, jump: 1.6, color: '#F7DC6F' }
        ];

        const maps = [
            {
                id: 1,
                name: 'Pine Valley',
                skyColor: '#87CEEB',
                groundColor: '#3d5a3d',
                dirtColor: '#6B4423',
                fogColor: '#B0C4DE',
                trails: [
                    { id: 1, name: 'Easy Street', difficulty: 'green', length: 1500, features: 'gentle' },
                    { id: 2, name: 'Gentle Slope', difficulty: 'green', length: 1600, features: 'gentle' },
                    { id: 3, name: 'Twisted Path', difficulty: 'blue', length: 2000, features: 'mixed' },
                    { id: 4, name: 'Rocky Ridge', difficulty: 'blue', length: 2200, features: 'mixed' },
                    { id: 5, name: 'Death Drop', difficulty: 'black', length: 2800, features: 'extreme' },
                    { id: 6, name: 'The Gauntlet', difficulty: 'black', length: 3000, features: 'extreme' }
                ]
            },
            {
                id: 2,
                name: 'Desert Peak',
                skyColor: '#FFD700',
                groundColor: '#8B7355',
                dirtColor: '#CD853F',
                fogColor: '#F4A460',
                trails: [
                    { id: 1, name: 'Sand Cruise', difficulty: 'green', length: 1500, features: 'gentle' },
                    { id: 2, name: 'Dune Runner', difficulty: 'green', length: 1700, features: 'gentle' },
                    { id: 3, name: 'Canyon Carver', difficulty: 'blue', length: 2100, features: 'mixed' },
                    { id: 4, name: 'Mesa Madness', difficulty: 'blue', length: 2300, features: 'mixed' },
                    { id: 5, name: 'Cactus Chaos', difficulty: 'black', length: 2900, features: 'extreme' },
                    { id: 6, name: 'Scorpion Sting', difficulty: 'black', length: 3100, features: 'extreme' }
                ]
            },
            {
                id: 3,
                name: 'Alpine Heights',
                skyColor: '#B0E0E6',
                groundColor: '#556B2F',
                dirtColor: '#696969',
                fogColor: '#D3D3D3',
                trails: [
                    { id: 1, name: 'Beginner Bowl', difficulty: 'green', length: 1500, features: 'gentle' },
                    { id: 2, name: 'Meadow Run', difficulty: 'green', length: 1800, features: 'gentle' },
                    { id: 3, name: 'Avalanche Alley', difficulty: 'blue', length: 2200, features: 'mixed' },
                    { id: 4, name: 'Ice Breaker', difficulty: 'blue', length: 2400, features: 'mixed' },
                    { id: 5, name: 'Summit Screamer', difficulty: 'black', length: 3000, features: 'extreme' },
                    { id: 6, name: 'Widow Maker', difficulty: 'black', length: 3200, features: 'extreme' }
                ]
            }
        ];

        const getDifficultyColor = (diff) => {
            if (diff === 'green') return '#4CAF50';
            if (diff === 'blue') return '#2196F3';
            return '#212121';
        };

        const getDifficultyIcon = (diff) => {
            if (diff === 'green') return <Circle className="w-4 h-4" />;
            if (diff === 'blue') return <Square className="w-4 h-4" />;
            return <Diamond className="w-4 h-4" />;
        };

        useEffect(() => {
            if (screen === 'playing' && canvasRef.current) {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                canvas.width = 1000;
                canvas.height = 700;

                const bike = bikes.find(b => b.id === selectedBike);
                const game = {
                    player: {
                        x: 0,
                        y: 10,
                        z: 20,
                        vx: 0,
                        vy: 0,
                        vz: 8,
                        rotY: 0,
                        rotVel: 0,
                        pitch: 0,
                        onGround: false,
                        distance: 0
                    },
                    terrain: [],
                    objects: [],
                    trees: [],
                    mountainSides: [],
                    time: 0,
                    crashed: false,
                    finished: false,
                    speed: 0,
                    startTime: 0
                };

                // Generate terrain path
                const segmentLength = 5;
                const numSegments = Math.ceil(selectedTrail.length / segmentLength);
                let currentHeight = 50; // Start high on mountain
                let pathCurve = 0;
                
                for (let i = 0; i < numSegments; i++) {
                    const z = i * segmentLength;
                    
                    // Add curves to the path
                    if (Math.random() < 0.1) {
                        pathCurve += (Math.random() - 0.5) * 2;
                    }
                    pathCurve *= 0.95;
                    
                    const segment = {
                        z: z,
                        centerX: pathCurve,
                        width: 12, // Increased from 8
                        height: currentHeight,
                        leftEdge: pathCurve - 6, // Increased from 4
                        rightEdge: pathCurve + 6 // Increased from 4
                    };

                    // Descend down the mountain
                    if (i > 0) {
                        // Always descending
                        if (selectedTrail.features === 'extreme') {
                            currentHeight -= 0.3 + Math.random() * 0.4;
                        } else if (selectedTrail.features === 'mixed') {
                            currentHeight -= 0.2 + Math.random() * 0.3;
                        } else {
                            currentHeight -= 0.15 + Math.random() * 0.2;
                        }
                    }

                    game.terrain.push(segment);

                    // Add mountain sides (terrain on both sides of trail)
                    for (let side = -1; side <= 1; side += 2) {
                        for (let offset = 1; offset <= 8; offset++) {
                            const sideX = pathCurve + side * (4 + offset * 3);
                            const sideHeight = currentHeight + (offset * 0.5) + (Math.random() - 0.5) * 2;
                            game.mountainSides.push({
                                x: sideX,
                                y: sideHeight,
                                z: z,
                                size: 3
                            });
                        }
                    }

                    // Add trees on the mountain sides - properly placed on terrain
                    if (i % 2 === 0 && i > 5) {
                        // Place trees on the mountain sides
                        const side = Math.random() < 0.5 ? -1 : 1;
                        const treeOffset = 8 + Math.random() * 15;
                        const treeX = pathCurve + side * treeOffset;
                        
                        // Calculate ground height at tree position (slopes up from trail)
                        const treeGroundHeight = currentHeight + (treeOffset - 8) * 0.5 + (Math.random() - 0.5) * 3;
                        
                        game.trees.push({
                            x: treeX,
                            y: treeGroundHeight,
                            z: z,
                            height: 15 + Math.random() * 10,
                            radius: 1.5 + Math.random() * 0.8
                        });
                        
                        // Add bushes near trees on the mountain slope
                        if (Math.random() < 0.6) {
                            const bushOffset = treeOffset + (Math.random() - 0.5) * 4;
                            const bushX = pathCurve + side * bushOffset;
                            const bushGroundHeight = currentHeight + (bushOffset - 8) * 0.5 + (Math.random() - 0.5) * 2;
                            
                            game.trees.push({
                                x: bushX,
                                y: bushGroundHeight,
                                z: z + (Math.random() - 0.5) * 8,
                                height: 2 + Math.random() * 2,
                                radius: 1 + Math.random() * 0.5,
                                isBush: true
                            });
                        }
                    }

                    // Add objects (rocks, logs, jumps, drops)
                    if (i > 10 && Math.random() < 0.15) {
                        const objType = Math.random();
                        let obj;

                        if (objType < 0.25 && selectedTrail.features !== 'gentle') {
                            // Jump
                            obj = {
                                type: 'jump',
                                x: pathCurve + (Math.random() - 0.5) * 3,
                                y: currentHeight,
                                z: z,
                                width: 6,
                                height: 1.5,
                                depth: 6,
                                color: '#8B4513'
                            };
                        } else if (objType < 0.4 && selectedTrail.features === 'extreme') {
                            // Drop
                            const dropHeight = 3 + Math.random() * 4;
                            obj = {
                                type: 'drop',
                                x: pathCurve,
                                y: currentHeight - dropHeight,
                                z: z,
                                width: 8,
                                height: dropHeight,
                                depth: 8,
                                color: '#654321'
                            };
                            currentHeight -= dropHeight;
                            for (let j = 0; j < 3; j++) {
                                if (game.terrain[i + j]) {
                                    game.terrain[i + j].height = currentHeight;
                                }
                            }
                        } else if (objType < 0.7) {
                            // Rock - can ride around
                            obj = {
                                type: 'rock',
                                x: pathCurve + (Math.random() - 0.5) * 5,
                                y: currentHeight,
                                z: z,
                                radius: 1 + Math.random() * 0.8,
                                color: '#666'
                            };
                        } else {
                            // Log - can ride around
                            obj = {
                                type: 'log',
                                x: pathCurve + (Math.random() - 0.5) * 5,
                                y: currentHeight,
                                z: z,
                                width: 0.6,
                                length: 3,
                                color: '#5D4037'
                            };
                        }
                        
                        game.objects.push(obj);
                    }
                }

                // Add finish line
                game.objects.push({
                    type: 'finish',
                    x: pathCurve,
                    y: currentHeight,
                    z: selectedTrail.length - 20,
                    width: 8,
                    height: 8,
                    depth: 1
                });

                const handleKeyDown = (e) => { 
                    keysRef.current[e.key] = true;
                    if (e.key === 'r' || e.key === 'R') {
                        if (game.crashed || game.finished) {
                            setScreen('trail-select');
                        }
                    }
                };
                const handleKeyUp = (e) => { keysRef.current[e.key] = false; };
                
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                const getTerrainAt = (x, z) => {
                    let closestSeg = null;
                    let minDist = Infinity;
                    
                    for (let seg of game.terrain) {
                        const dist = Math.abs(seg.z - z);
                        if (dist < minDist) {
                            minDist = dist;
                            closestSeg = seg;
                        }
                    }
                    
                    if (!closestSeg) return { height: 0, onTrack: false };
                    
                    const onTrack = x >= closestSeg.leftEdge && x <= closestSeg.rightEdge;
                    return { height: closestSeg.height, onTrack, centerX: closestSeg.centerX };
                };

                const project3D = (x, y, z) => {
                    const fov = 400;
                    const dx = x - game.player.x;
                    const dy = y - game.player.y;
                    const dz = z - game.player.z;
                    
                    // Rotate by player rotation
                    const rotatedX = dx * Math.cos(-game.player.rotY) - dz * Math.sin(-game.player.rotY);
                    const rotatedZ = dx * Math.sin(-game.player.rotY) + dz * Math.cos(-game.player.rotY);
                    
                    if (rotatedZ <= 0.1) return null;
                    
                    const scale = fov / rotatedZ;
                    return {
                        x: canvas.width / 2 + rotatedX * scale,
                        y: canvas.height / 2 - (dy - 2) * scale,
                        scale: scale,
                        depth: rotatedZ
                    };
                };

                const drawCylinder = (x, y, z, radius, height, color) => {
                    const topProj = project3D(x, y + height, z);
                    const bottomProj = project3D(x, y, z);
                    
                    if (!topProj || !bottomProj) return;
                    
                    const topRadius = radius * topProj.scale;
                    const bottomRadius = radius * bottomProj.scale;
                    
                    // Draw cylinder
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.ellipse(bottomProj.x, bottomProj.y, bottomRadius, bottomRadius * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = shadeColor(color, -20);
                    ctx.beginPath();
                    ctx.moveTo(bottomProj.x - bottomRadius, bottomProj.y);
                    ctx.lineTo(topProj.x - topRadius, topProj.y);
                    ctx.lineTo(topProj.x + topRadius, topProj.y);
                    ctx.lineTo(bottomProj.x + bottomRadius, bottomProj.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = shadeColor(color, 20);
                    ctx.beginPath();
                    ctx.ellipse(topProj.x, topProj.y, topRadius, topRadius * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                };

                const drawBox = (x, y, z, w, h, d, color) => {
                    const corners = [
                        [x - w/2, y, z - d/2], [x + w/2, y, z - d/2],
                        [x + w/2, y, z + d/2], [x - w/2, y, z + d/2],
                        [x - w/2, y + h, z - d/2], [x + w/2, y + h, z - d/2],
                        [x + w/2, y + h, z + d/2], [x - w/2, y + h, z + d/2]
                    ];

                    const projected = corners.map(c => project3D(c[0], c[1], c[2])).filter(p => p);
                    if (projected.length < 4) return;

                    const faces = [
                        [4, 5, 6, 7, shadeColor(color, 20)],  // Top
                        [2, 3, 7, 6, shadeColor(color, 0)],   // Front
                        [1, 2, 6, 5, shadeColor(color, -20)], // Right
                        [0, 1, 5, 4, shadeColor(color, -40)]  // Left
                    ];

                    faces.forEach(face => {
                        if (projected[face[0]] && projected[face[1]] && projected[face[2]] && projected[face[3]]) {
                            ctx.fillStyle = face[4];
                            ctx.beginPath();
                            ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                            ctx.lineTo(projected[face[1]].x, projected[face[1]].y);
                            ctx.lineTo(projected[face[2]].x, projected[face[2]].y);
                            ctx.lineTo(projected[face[3]].x, projected[face[3]].y);
                            ctx.closePath();
                            ctx.fill();
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    });
                };

                const shadeColor = (color, percent) => {
                    const num = parseInt(color.replace("#",""), 16);
                    const amt = Math.round(2.55 * percent);
                    const R = Math.max(0, Math.min(255, (num >> 16) + amt));
                    const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
                    const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
                    return "#" + ((R << 16) | (G << 8) | B).toString(16).padStart(6, '0');
                };

                const gameLoop = () => {
                    if (game.crashed || game.finished) {
                        return;
                    }

                    // Wait 1 second before starting to prevent immediate crash
                    if (game.time < 1.0) {
                        game.time += 0.016;
                        
                        // Still render during countdown
                        ctx.fillStyle = selectedMap.skyColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw distant mountains
                        ctx.fillStyle = shadeColor(selectedMap.groundColor, -40);
                        ctx.beginPath();
                        for (let i = 0; i < canvas.width; i += 50) {
                            const height = 200 + Math.sin(i * 0.01) * 100;
                            if (i === 0) ctx.moveTo(i, height);
                            else ctx.lineTo(i, height);
                        }
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.lineTo(0, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 48px Arial';
                        const countdown = Math.ceil(1.0 - game.time);
                        ctx.fillText(countdown > 0 ? countdown : 'GO!', canvas.width/2 - 30, canvas.height/2 + 15);
                        
                        animationRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    game.time += 0.016;
                    const keys = keysRef.current;

                    // Controls - FIXED: negative rotation = left, positive = right
                    const accel = 0.3 * bike.speed;
                    const turnSpeed = 0.015 * bike.handling;
                    const jumpPower = 10 * bike.jump;

                    if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                        game.player.vz += accel; // W = accelerate
                    }
                    if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                        game.player.vz -= accel * 0.5; // S = slow down
                    }
                    if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                        game.player.rotVel += turnSpeed; // A = left (positive rotation in our coordinate system)
                        game.player.vx += 0.08;
                    }
                    if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                        game.player.rotVel -= turnSpeed; // D = right (negative rotation in our coordinate system)
                        game.player.vx -= 0.08;
                    }
                    if (keys[' '] && game.player.onGround) {
                        game.player.vy = jumpPower;
                        game.player.onGround = false;
                    }

                    // Physics
                    game.player.vz = Math.max(3, Math.min(game.player.vz, 30));
                    game.player.rotY += game.player.rotVel;
                    game.player.rotVel *= 0.90;
                    game.player.vx *= 0.95;
                    
                    // Limit rotation velocity to prevent spinning
                    game.player.rotVel = Math.max(-0.05, Math.min(game.player.rotVel, 0.05));

                    const moveX = Math.sin(game.player.rotY) * game.player.vz * 0.016 + game.player.vx * 0.016;
                    const moveZ = Math.cos(game.player.rotY) * game.player.vz * 0.016;

                    game.player.x += moveX;
                    game.player.z += moveZ;
                    game.player.vy -= 0.6; // Gravity
                    game.player.y += game.player.vy * 0.016;

                    const terrainInfo = getTerrainAt(game.player.x, game.player.z);
                    
                    if (game.player.y <= terrainInfo.height + 2) {
                        game.player.y = terrainInfo.height + 2;
                        
                        if (game.player.vy < -12) {
                            game.crashed = true;
                        }
                        
                        game.player.vy = 0;
                        game.player.onGround = true;
                    } else {
                        game.player.onGround = false;
                    }

                    // Check off track
                    if (!terrainInfo.onTrack && game.player.onGround) {
                        game.crashed = true;
                    }

                    // Collision with objects
                    game.objects.forEach(obj => {
                        const dx = obj.x - game.player.x;
                        const dz = obj.z - game.player.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (obj.type === 'rock' && dist < obj.radius + 1.5) {
                            if (game.player.onGround) {
                                game.crashed = true;
                            }
                        } else if (obj.type === 'log' && dist < 2) {
                            if (game.player.onGround) {
                                game.crashed = true;
                            }
                        } else if (obj.type === 'finish' && game.player.z >= obj.z) {
                            game.finished = true;
                        }
                    });

                    game.player.distance = game.player.z;
                    game.speed = game.player.vz;

                    // Render
                    ctx.fillStyle = selectedMap.skyColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw distant mountains in background
                    ctx.fillStyle = shadeColor(selectedMap.groundColor, -40);
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    for (let i = 0; i < canvas.width; i += 30) {
                        const height = 150 + Math.sin(i * 0.008 + game.player.z * 0.01) * 80;
                        if (i === 0) ctx.moveTo(i, height);
                        else ctx.lineTo(i, height);
                    }
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.lineTo(0, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1.0;

                    // Draw middle distance mountains
                    ctx.fillStyle = shadeColor(selectedMap.groundColor, -20);
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < canvas.width; i += 40) {
                        const height = 250 + Math.sin(i * 0.012 + game.player.z * 0.015) * 60;
                        if (i === 0) ctx.moveTo(i, height);
                        else ctx.lineTo(i, height);
                    }
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.lineTo(0, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1.0;

                    // Collect and sort objects by depth
                    const renderQueue = [];

                    // Add mountain sides (terrain slopes)
                    game.mountainSides.forEach(side => {
                        if (side.z > game.player.z - 20 && side.z < game.player.z + 150) {
                            const p = project3D(side.x, side.y, side.z);
                            if (p) {
                                renderQueue.push({ depth: p.depth, fn: () => {
                                    const terrainColor = selectedMap.groundColor;
                                    ctx.fillStyle = shadeColor(terrainColor, -10 - (Math.abs(side.x) * 2));
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, side.size * p.scale, 0, Math.PI * 2);
                                    ctx.fill();
                                }});
                            }
                        }
                    });

                    // Add trees
                    game.trees.forEach(tree => {
                        if (tree.z > game.player.z - 20 && tree.z < game.player.z + 150) {
                            const p = project3D(tree.x, tree.y, tree.z);
                            if (p) {
                                renderQueue.push({ depth: p.depth, fn: () => {
                                    if (tree.isBush) {
                                        // Draw bushes
                                        drawCylinder(tree.x, tree.y, tree.z, tree.radius, tree.height, '#2d5016');
                                    } else {
                                        // Draw tree trunk with texture
                                        const trunkColor = '#3d2817';
                                        drawCylinder(tree.x, tree.y, tree.z, tree.radius * 0.6, tree.height * 0.3, trunkColor);
                                        
                                        // Draw foliage in layers for depth
                                        const foliageColor = '#2d5016';
                                        const layers = 3;
                                        for (let i = 0; i < layers; i++) {
                                            const layerHeight = tree.height * 0.3 + (i * tree.height * 0.23);
                                            const layerRadius = tree.radius * (1.8 - i * 0.3);
                                            drawCylinder(tree.x, tree.y + layerHeight, tree.z, layerRadius, tree.height * 0.23, 
                                                                shadeColor(foliageColor, i * 10));
                                        }
                                    }
                                }});
                            }
                        }
                    });

                    // Add terrain segments
                    for (let i = 0; i < game.terrain.length - 1; i++) {
                        const seg = game.terrain[i];
                        const nextSeg = game.terrain[i + 1];

                        if (seg.z > game.player.z - 10 && seg.z < game.player.z + 150) {
                            const p = project3D(seg.centerX, seg.height, seg.z);
                            if (p) {
                                renderQueue.push({ depth: p.depth, fn: () => {
                                    // Draw track segment as quad
                                    const p1 = project3D(seg.leftEdge, seg.height, seg.z);
                                    const p2 = project3D(seg.rightEdge, seg.height, seg.z);
                                    const p3 = project3D(nextSeg.rightEdge, nextSeg.height, nextSeg.z);
                                    const p4 = project3D(nextSeg.leftEdge, nextSeg.height, nextSeg.z);

                                    if (p1 && p2 && p3 && p4) {
                                        // Draw dirt with gradient
                                        const dirtGrad = ctx.createLinearGradient(p1.x, p1.y, p3.x, p3.y);
                                        dirtGrad.addColorStop(0, selectedMap.dirtColor);
                                        dirtGrad.addColorStop(0.5, shadeColor(selectedMap.dirtColor, -10));
                                        dirtGrad.addColorStop(1, shadeColor(selectedMap.dirtColor, 10));
                                        ctx.fillStyle = dirtGrad;
                                        ctx.beginPath();
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p2.x, p2.y);
                                        ctx.lineTo(p3.x, p3.y);
                                        ctx.lineTo(p4.x, p4.y);
                                        ctx.closePath();
                                        ctx.fill();
                                        
                                        // Add tire tracks for realism
                                        if (i % 2 === 0) {
                                            ctx.strokeStyle = shadeColor(selectedMap.dirtColor, -20);
                                            ctx.lineWidth = 1;
                                            const trackOffset = seg.width * 0.2;
                                            const pLeft1 = project3D(seg.centerX - trackOffset, seg.height, seg.z);
                                            const pLeft2 = project3D(nextSeg.centerX - trackOffset, nextSeg.height, nextSeg.z);
                                            const pRight1 = project3D(seg.centerX + trackOffset, seg.height, seg.z);
                                            const pRight2 = project3D(nextSeg.centerX + trackOffset, nextSeg.height, nextSeg.z);
                                            
                                            if (pLeft1 && pLeft2) {
                                                ctx.beginPath();
                                                ctx.moveTo(pLeft1.x, pLeft1.y);
                                                ctx.lineTo(pLeft2.x, pLeft2.y);
                                                ctx.stroke();
                                            }
                                            if (pRight1 && pRight2) {
                                                ctx.beginPath();
                                                ctx.moveTo(pRight1.x, pRight1.y);
                                                ctx.lineTo(pRight2.x, pRight2.y);
                                                ctx.stroke();
                                            }
                                        }

                                        // Draw track edges with grass
                                        ctx.strokeStyle = '#1a3d0a';
                                        ctx.lineWidth = 3;
                                        ctx.beginPath();
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p4.x, p4.y);
                                        ctx.stroke();
                                        ctx.beginPath();
                                        ctx.moveTo(p2.x, p2.y);
                                        ctx.lineTo(p3.x, p3.y);
                                        ctx.stroke();
                                    }
                                }});
                            }
                        }
                    }

                    // Add objects
                    game.objects.forEach(obj => {
                        if (obj.z > game.player.z - 5 && obj.z < game.player.z + 150) {
                            const p = project3D(obj.x, obj.y, obj.z);
                            if (p) {
                                renderQueue.push({ depth: p.depth, fn: () => {
                                    if (obj.type === 'rock') {
                                        const topP = project3D(obj.x, obj.y + obj.radius, obj.z);
                                        if (topP) {
                                            const size = obj.radius * topP.scale;
                                            ctx.fillStyle = obj.color;
                                            ctx.beginPath();
                                            ctx.arc(topP.x, topP.y, size, 0, Math.PI * 2);
                                            ctx.fill();
                                            ctx.strokeStyle = '#000';
                                            ctx.lineWidth = 2;
                                            ctx.stroke();
                                        }
                                    } else if (obj.type === 'log') {
                                        drawBox(obj.x, obj.y, obj.z, obj.width, obj.width, obj.length, obj.color);
                                    } else if (obj.type === 'jump') {
                                        drawBox(obj.x, obj.y, obj.z, obj.width, obj.height, obj.depth, obj.color);
                                    } else if (obj.type === 'finish') {
                                        for (let i = 0; i < 4; i++) {
                                            for (let j = 0; j < 4; j++) {
                                                const color = (i + j) % 2 === 0 ? '#FFF' : '#000';
                                                drawBox(obj.x - 4 + i * 2, obj.y + j * 2, obj.z, 2, 2, obj.depth, color);
                                            }
                                        }
                                    }
                                }});
                            }
                        }
                    });

                    // Sort by depth (far to near)
                    renderQueue.sort((a, b) => b.depth - a.depth);
                    renderQueue.forEach(item => item.fn());

                    // Draw bike from first person - front wheel, fork, and handlebars
                    const wheelRadius = 50;
                    const wheelY = canvas.height - 60;
                    
                    // Fork legs - angled for realism
                    const forkGrad = ctx.createLinearGradient(canvas.width/2 - 30, 0, canvas.width/2 + 30, 0);
                    forkGrad.addColorStop(0, '#2a2a2a');
                    forkGrad.addColorStop(0.5, '#4a4a4a');
                    forkGrad.addColorStop(1, '#2a2a2a');
                    ctx.fillStyle = forkGrad;
                    
                    // Left fork leg
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 30, canvas.height - 180);
                    ctx.lineTo(canvas.width/2 - 22, wheelY - 50);
                    ctx.lineTo(canvas.width/2 - 15, wheelY - 50);
                    ctx.lineTo(canvas.width/2 - 20, canvas.height - 180);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Right fork leg
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 + 30, canvas.height - 180);
                    ctx.lineTo(canvas.width/2 + 22, wheelY - 50);
                    ctx.lineTo(canvas.width/2 + 15, wheelY - 50);
                    ctx.lineTo(canvas.width/2 + 20, canvas.height - 180);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Fork crown (connects the legs)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(canvas.width/2 - 35, canvas.height - 185, 70, 12);
                    
                    // Stem (connects fork to handlebars)
                    ctx.fillStyle = '#333';
                    ctx.fillRect(canvas.width/2 - 15, canvas.height - 220, 30, 40);
                    
                    // Front wheel - with 3D effect
                    const wheelGrad = ctx.createRadialGradient(canvas.width/2, wheelY, 0, canvas.width/2, wheelY, wheelRadius);
                    wheelGrad.addColorStop(0, '#1a1a1a');
                    wheelGrad.addColorStop(0.7, '#0a0a0a');
                    wheelGrad.addColorStop(1, '#000');
                    ctx.fillStyle = wheelGrad;
                    ctx.beginPath();
                    ctx.ellipse(canvas.width/2, wheelY, wheelRadius, wheelRadius * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Tire sidewall
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.ellipse(canvas.width/2, wheelY, wheelRadius - 3, (wheelRadius * 0.25) - 1, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Tire tread pattern
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 10;
                    ctx.beginPath();
                    ctx.ellipse(canvas.width/2, wheelY, wheelRadius - 8, (wheelRadius * 0.25) - 3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner tread details
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2 + game.time * 8;
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        const r1 = wheelRadius - 15;
                        const r2 = wheelRadius - 5;
                        const x1 = canvas.width/2 + Math.cos(angle) * r1;
                        const y1 = wheelY + Math.sin(angle) * r1 * 0.25;
                        const x2 = canvas.width/2 + Math.cos(angle) * r2;
                        const y2 = wheelY + Math.sin(angle) * r2 * 0.25;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    
                    // Wheel spokes (rotating)
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2 + game.time * 8;
                        const x1 = canvas.width/2 + Math.cos(angle) * 8;
                        const y1 = wheelY + Math.sin(angle) * 2;
                        const x2 = canvas.width/2 + Math.cos(angle) * (wheelRadius - 15);
                        const y2 = wheelY + Math.sin(angle) * ((wheelRadius * 0.25) - 4);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    
                    // Hub (center of wheel)
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(canvas.width/2, wheelY, 10, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Quick release skewer
                    ctx.fillStyle = '#888';
                    ctx.beginPath();
                    ctx.ellipse(canvas.width/2, wheelY, 12, 3.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Handlebars - more realistic mountain bike bars
                    const barWidth = 380;
                    const barY = canvas.height - 140;
                    const gripSize = 40;
                    const gripHeight = 100;
                    
                    // Bar extensions (from stem to grips)
                    ctx.strokeStyle = bike.color;
                    ctx.lineWidth = 10;
                    ctx.lineCap = 'round';
                    
                    // Left bar
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 20, barY - 20);
                    ctx.quadraticCurveTo(canvas.width/2 - 100, barY - 10, canvas.width/2 - (barWidth/2) + gripSize/2, barY);
                    ctx.stroke();
                    
                    // Right bar
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 + 20, barY - 20);
                    ctx.quadraticCurveTo(canvas.width/2 + 100, barY - 10, canvas.width/2 + (barWidth/2) - gripSize/2, barY);
                    ctx.stroke();

                    // Grips
                    ctx.fillStyle = '#111';
                    ctx.fillRect(canvas.width/2 - (barWidth/2) - 10, barY - gripSize/2, gripSize, gripSize); // Left
                    ctx.fillRect(canvas.width/2 + (barWidth/2) - gripSize + 10, barY - gripSize/2, gripSize, gripSize); // Right

                    // Gear/Brake Levers
                    ctx.fillStyle = '#333';
                    ctx.fillRect(canvas.width/2 - 120, barY - 50, 30, 10);
                    ctx.fillRect(canvas.width/2 + 90, barY - 50, 30, 10);
                    
                    // HUD
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`Speed: ${game.speed.toFixed(1)} km/h`, 20, 30);
                    ctx.fillText(`Distance: ${(game.player.distance / 1000).toFixed(2)} km / ${(selectedTrail.length / 1000).toFixed(2)} km`, 20, 60);
                    
                    const timeElapsed = game.time - 1.0;
                    const minutes = Math.floor(timeElapsed / 60);
                    const seconds = Math.floor(timeElapsed % 60);
                    const ms = Math.floor((timeElapsed * 100) % 100);
                    ctx.fillText(`Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`, 20, 90);

                    // Game Over / Finish
                    if (game.crashed) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.fillRect(0, canvas.height/2 - 50, canvas.width, 100);
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 60px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('CRASHED!', canvas.width/2, canvas.height/2 + 20);
                        ctx.font = '24px Arial';
                        ctx.fillText('Press R to return to Trail Select', canvas.width/2, canvas.height/2 + 60);
                    } else if (game.finished) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                        ctx.fillRect(0, canvas.height/2 - 50, canvas.width, 100);
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 60px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('FINISHED!', canvas.width/2, canvas.height/2 + 20);
                        ctx.font = '24px Arial';
                        ctx.fillText(`Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`, canvas.width/2, canvas.height/2 + 60);
                        ctx.font = '24px Arial';
                        ctx.fillText('Press R to return to Trail Select', canvas.width/2, canvas.height/2 + 90);
                    } else {
                        animationRef.current = requestAnimationFrame(gameLoop);
                    }
                };

                gameLoop();
                game.startTime = Date.now();

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }
        }, [screen, selectedBike, selectedMap, selectedTrail]);

        // Screen Rendering
        // ---

        const MenuScreen = () => (
            <div style={{ padding: '40px', maxWidth: '800px', margin: 'auto', textAlign: 'center', backgroundColor: '#1E2B38', color: '#E5E7EB', borderRadius: '10px' }}>
                <h1 style={{ color: '#4ECDC4', fontSize: '3em' }}>Mountain Bike 3D</h1>
                <p>Welcome to the 3D Mountain Bike experience! Select your bike to start.</p>
                <div style={{ marginTop: '30px' }}>
                    {bikes.map(bike => (
                        <button
                            key={bike.id}
                            onClick={() => { setSelectedBike(bike.id); setScreen('map-select'); }}
                            style={{
                                display: 'block',
                                width: '100%',
                                padding: '15px',
                                margin: '10px 0',
                                backgroundColor: bike.color,
                                border: 'none',
                                borderRadius: '5px',
                                color: '#000',
                                fontWeight: 'bold',
                                cursor: 'pointer',
                                transition: 'background-color 0.2s',
                            }}
                        >
                            {bike.name} (Speed: {bike.speed.toFixed(1)}, Handling: {bike.handling.toFixed(1)})
                        </button>
                    ))}
                </div>
            </div>
        );

        const MapSelectScreen = () => (
            <div style={{ padding: '40px', maxWidth: '800px', margin: 'auto', textAlign: 'center', backgroundColor: '#1E2B38', color: '#E5E7EB', borderRadius: '10px' }}>
                <h1 style={{ color: '#4ECDC4', fontSize: '2.5em' }}>Select Your Map</h1>
                <p>Choose a mountain range to ride.</p>
                <div style={{ marginTop: '30px', display: 'flex', justifyContent: 'space-around' }}>
                    {maps.map(map => (
                        <div
                            key={map.id}
                            onClick={() => { setSelectedMap(map); setScreen('trail-select'); }}
                            style={{
                                width: '30%',
                                padding: '20px',
                                backgroundColor: map.skyColor,
                                color: '#000',
                                borderRadius: '8px',
                                cursor: 'pointer',
                                transition: 'transform 0.2s',
                                boxShadow: '0 4px 8px rgba(0,0,0,0.3)',
                                minHeight: '150px'
                            }}
                        >
                            <Mountain className="w-10 h-10 mx-auto" style={{ color: map.groundColor }} />
                            <h2 style={{ marginTop: '10px' }}>{map.name}</h2>
                            <p style={{ fontSize: '0.8em', color: shadeColor(map.skyColor, -80) }}>{map.trails.length} Trails</p>
                        </div>
                    ))}
                </div>
                <button
                    onClick={() => setScreen('menu')}
                    style={{ marginTop: '30px', padding: '10px 20px', backgroundColor: '#F7DC6F', border: 'none', borderRadius: '5px', fontWeight: 'bold', cursor: 'pointer' }}
                >
                    &larr; Back to Bikes
                </button>
            </div>
        );

        const TrailSelectScreen = () => {
            if (!selectedMap) {
                setScreen('map-select');
                return null;
            }

            return (
                <div style={{ padding: '40px', maxWidth: '800px', margin: 'auto', textAlign: 'center', backgroundColor: '#1E2B38', color: '#E5E7EB', borderRadius: '10px' }}>
                    <h1 style={{ color: '#4ECDC4', fontSize: '2.5em' }}>{selectedMap.name} Trails</h1>
                    <p>Select your trail challenge.</p>
                    <div style={{ marginTop: '30px' }}>
                        {selectedMap.trails.map(trail => (
                            <div
                                key={trail.id}
                                onClick={() => { setSelectedTrail(trail); setScreen('playing'); }}
                                style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '15px',
                                    margin: '10px 0',
                                    backgroundColor: '#2D3A47',
                                    borderLeft: `5px solid ${getDifficultyColor(trail.difficulty)}`,
                                    borderRadius: '5px',
                                    cursor: 'pointer',
                                    transition: 'background-color 0.2s',
                                    textAlign: 'left'
                                }}
                            >
                                <div style={{ display: 'flex', alignItems: 'center' }}>
                                    <span style={{ color: getDifficultyColor(trail.difficulty) }}>
                                        {getDifficultyIcon(trail.difficulty)}
                                    </span>
                                    <span style={{ marginLeft: '10px', fontWeight: 'bold' }}>{trail.name}</span>
                                </div>
                                <span style={{ color: '#aaa', fontSize: '0.9em' }}>
                                    {trail.length / 1000} km - {trail.features}
                                </span>
                            </div>
                        ))}
                    </div>
                    <button
                        onClick={() => { setSelectedMap(null); setScreen('map-select'); }}
                        style={{ marginTop: '30px', padding: '10px 20px', backgroundColor: '#F7DC6F', border: 'none', borderRadius: '5px', fontWeight: 'bold', cursor: 'pointer' }}
                    >
                        &larr; Back to Maps
                    </button>
                </div>
            );
        };

        const PlayingScreen = () => (
            <div style={{ backgroundColor: '#000', height: '100vh', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                <canvas ref={canvasRef} />
            </div>
        );

        switch (screen) {
            case 'menu':
                return <MenuScreen />;
            case 'map-select':
                return <MapSelectScreen />;
            case 'trail-select':
                return <TrailSelectScreen />;
            case 'playing':
                return <PlayingScreen />;
            default:
                return <MenuScreen />;
        }
    };

    // Render the main component
    ReactDOM.render(
        <MountainBikeGame />,
        document.getElementById('root')
    );
    // END OF CORRECTED CODE
</script>
